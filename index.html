<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, user-scalable=no">
        <!-- the line above, if uncommented, mostly makes a page mobile friendly without any further work needed, except it disables zoom on mobile -->
        <script src="https://supertestnet.github.io/bitcoin-chess/js/bitcoinjs-lib.js"></script>
        <script src="https://supertestnet.github.io/musig-playground/main.js"></script>
        <script src="https://unpkg.com/@cmdcode/crypto-utils@1.9.0"></script>
        <script src="https://bundle.run/browserify-cipher@1.0.1"></script>
        <script src="https://unpkg.com/@cmdcode/tapscript@1.2.7"></script>
        <script src="https://bundle.run/noble-secp256k1@1.2.14"></script>
        <style>
            * {
                box-sizing: border-box;
                font-size: 1.15rem;
                font-family: Arial, sans-serif;
            }
            html {
                max-width: 70ch;
                padding: 3rem 1rem;
                margin: auto;
                line-height: 1.25;
            }
            body {
                word-wrap: break-word;
            }
            h1 {
                font-size: 2rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            input {
                line-height: 1.25;
                width: 100%;
                height: 1.8rem;
                font-size: 1.15rem;
                border: 1px solid grey;
            }
            .participant {
                display: none;
            }
            @media screen and (max-width: 600px) {
            }
        </style>
        <script>
            sessionStorage.clear();
            var $ = document.querySelector.bind( document );
            var $$ = document.querySelectorAll.bind( document );
            var url_params = new URLSearchParams( window.location.search );
            var url_keys = url_params.keys();
            var $_GET = {}
            for ( var key of url_keys ) $_GET[ key ] = url_params.get( key );
        </script>
        <script>
            function waitSomeSeconds( num ) {
                num = Number( num ) * 1000;
                return new Promise( resolve => setTimeout( resolve, num ) );
            }
            function bytesToHex( bytes ) {
                return bytes.reduce( ( str, byte ) => str + byte.toString( 16 ).padStart( 2, "0" ), "" );
            }
            function textToHex( text ) {
                var encoder = new TextEncoder().encode( text );
                return [...new Uint8Array(encoder)]
                    .map( x => x.toString( 16 ).padStart( 2, "0" ) )
                    .join( "" );
            }
            async function waitForNonces() {
                var num = publicData.nonces.length;
                if ( num != publicData.numberOfParticipants + 1 ) {
                    await waitSomeSeconds( 1 );
                    var newnum = await waitForNonces();
                    return newnum;
                }
                return num;
            }
            async function getNote( item ) {
                async function isNoteSetYet( note_i_seek ) {
                    return new Promise( function( resolve, reject ) {
                        if ( !note_i_seek ) {
                            setTimeout( async function() {
                                var msg = await isNoteSetYet( sessionStorage[ item ] );
                                resolve( msg );
                            }, 100 );
                        } else {
                            resolve( note_i_seek );
                        }
                    });
                }
                async function getTimeoutData() {
                    var note_i_seek = await isNoteSetYet( sessionStorage[ item ] );
                    return note_i_seek;
                }
                var returnable = await getTimeoutData();
                return returnable;
            }
        </script>
        <script>
            var { getSharedSecret, schnorr, utils } = nobleSecp256k1;
            var crypto  = window.crypto;
            var getRand = size => crypto.getRandomValues(new Uint8Array(size));
            var sha256  = bitcoinjs.crypto.sha256;
            var keypair = bitcoinjs.ECPair.makeRandom();
            var privKey = keypair.privateKey.toString( "hex" );
            var pubKey  = keypair.publicKey.toString( "hex" );
            pubKey      = pubKey.substring( 2 );
            console.log( pubKey );
            var relays = ["wss://relay1.nostrchat.io","wss://relay.damus.io"];
            var relays_obj = {}
            // var socket = new WebSocket( relay );
        </script>
        <script>
            var mempoolnet = "testnet";
            var mempoolNetwork = "testnet/"; //mainnet: "" | signet: "signet/"
            if ( $_GET[ "network" ] == "testnet" ) {
                mempoolNetwork = "testnet/";
                mempoolnet = "testnet";
            }
            if ( $_GET[ "network" ] == "signet" ) {
                mempoolNetwork = "signet/";
                mempoolnet = "testnet"; //this one is identical for testnet and signet
            }
            if ( $_GET[ "network" ] == "mainnet" ) {
                mempoolNetwork = "";
                mempoolnet = "mainnet";
            }
            if ( $_GET[ "network" ] == "regtest" ) {
                mempoolNetwork = "";
                mempoolnet = "regtest";
            }
            var ready = [];
            var sessionShard = null;
            var sessionHash = null;
            var otherShards = {};
            var otherShardPreimages = [];
            var allShards = null;
            var privateSigners = [];
            var shardgivers = [];
            var commitments = [];
            var nonceorder = [];
            var sigorder = [];
            var altsessions = [];
            var the_tx = [];
            window.onload = () => {
                if ( !$_GET[ "pubkey" ] ) return;
                sessionShard = bytesToHex( nobleSecp256k1.getPublicKey( nobleSecp256k1.utils.randomPrivateKey(), true ) );
                sessionHash = bytesToHex( bitcoinjs.crypto.sha256( btcjs.Buffer.from( sessionShard, "hex" ) ) );
                otherShards[ pubKey ] = sessionHash;
            }
            const knownSigner = {
                privateKey: btcjs.BigInteger.fromHex( "abababababababababababababababababababababababababababababababab" ),
                session: null,
            }
            const signerPrivateData = {
                privateKey: btcjs.BigInteger.fromHex( privKey ),
                session: null,
            }
            var publicData = {
                address: null,
                numberOfParticipants: 0,
                pubKeys: [],
                message: null,
                pubKeyHash: null,
                pubKeyCombined: null,
                pubKeyParity: null,
                commitments: [],
                nonces: [],
                nonceCombined: null,
                partialSignatures: [],
                signature: null,
            }
            function add2Pubkeys( pubkey1, pubkey2 ) {
                var combokey = nobleSecp256k1.Point.fromHex( pubkey1 ).add( nobleSecp256k1.Point.fromHex( pubkey2 ) ).toHex();
                return bitcoinjs.ECPair.fromPublicKey( btcjs.Buffer.from( combokey, "hex" ) ).publicKey.toString( "hex" );
            }
        </script>
        <script>
            var handleKey = async (key,shard) => {
                var pubkeys = [];
                publicData.pubKeys.forEach( item => {
                    pubkeys.push( bytesToHex( item ) );
                });
                if ( pubkeys.includes( key ) ) return;
                if ( publicData.pubKeys.length != publicData.numberOfParticipants ) {
                    otherShards[ key ] = shard;
                    publicData.pubKeys.push( btcjs.Buffer.from( key, 'hex' ) );
                    $$( '.keycount' ).forEach( function( item ) {
                        var newnum = Number( item.innerText.split( " " )[ 0 ] ) + 1;
                        item.innerText = newnum;
                    });
                    console.log( 0, publicData.pubKeys.length, publicData.numberOfParticipants );
                    if ( publicData.pubKeys.length == publicData.numberOfParticipants ) {
                        console.log( 1 );
                        var event2 = {
                            "content"   : encrypt( privKey, $_GET[ "pubkey" ], `{"phase":0}` ),
                            "created_at" : Math.floor( Date.now() / 1000 ),
                            "kind"      : 4,
                            "tags"      : [ [ 'p', $_GET[ "pubkey" ] ] ],
                            "pubkey"    : pubKey,
                        }
                        var signedEvent2 = await getSignedEvent(event2, privKey);
                        Object.keys( relays_obj ).forEach( function( relay ) {
                            relays_obj[ relay ].send(JSON.stringify([ "EVENT", signedEvent2 ]));
                        });
                        publicData.pubKeys.push( btcjs.Buffer.from( "81aaadc8a5e83f4576df823cf22a5b1969cf704a0d5f6f68bd757410c9917aac", 'hex' ) );
                        publicData.pubKeys.sort((a,b) => {var array = [bytesToHex(a),bytesToHex(b)].sort();if ( bytesToHex(a) == array[ 1 ]) return 1; else return -1;});
                        var pubkeys = [];
                        publicData.pubKeys.forEach( item => {
                            pubkeys.push( bytesToHex( item ) );
                        });
                        console.log( "pubkeys:", pubkeys );
                        publicData.pubKeyHash = btcjs.muSig.computeEll(publicData.pubKeys);
                        console.log( "pubkeys hash:", bytesToHex( publicData.pubKeyHash ) );
                        const pkCombined = btcjs.muSig.pubKeyCombine(publicData.pubKeys, publicData.pubKeyHash);
                        publicData.pubKeyCombined = btcjs.convert.intToBuffer(pkCombined.affineX);
                        publicData.pubKeyParity = btcjs.math.isEven(pkCombined);
                        var combokey = publicData.pubKeyCombined.toString( "hex" );
                        var address = tapscript.Address.p2tr.encode( combokey, mempoolnet );
                        watchForMovement( address, mempoolNetwork );
                        var p = document.createElement( "p" );
                        p.innerText = `Phase 1 of 5 complete, all pubkeys known -- now waiting for the coordinator to deposit money into this address: ${address} -- this page should automatically detect when it arrives and move onto the next step`;
                        $( '.participant' ).append( p );
                        console.log( "address:", address );
                        await waitSomeSeconds( 5 );
                        // var txid = prompt( "Enter the txid of your deposit" );
                        // var vout = prompt( "And the vout" );
                        // vout = Number( vout );
                        // var amt = prompt( "And the amount (in sats)" );
                        // amt = Number( amt );
                        await loopTilAddressReceivesMoney( address, mempoolNetwork );
                        await waitSomeSeconds( 2 );
                        var txinfo = await addressReceivedMoneyInThisTx( address, mempoolNetwork );
                        var txid = txinfo[ 0 ];
                        sessionStorage.funding_txid = txid;
                        var vout = txinfo[ 1 ];
                        var amt = txinfo[ 2 ];
                        var txdata = tapscript.Tx.create({
                          vin  : [{
                            txid: txid,
                            vout: vout,
                            prevout: {
                              value: amt,
                              scriptPubKey: [ 'OP_1', publicData.pubKeyCombined.toString( "hex" ) ]
                            },
                          }],
                          vout : [{
                            value: amt - 500,
                            //address: bcrt1q6zpf4gefu4ckuud3pjch563nm7x27u4ruahz3y
                            scriptPubKey: tapscript.Address.toScriptPubKey( publicData.address )
                          }]
                        });

                        var sighash = bytesToHex( tapscript.Signer.taproot.hash(txdata, 0, {sigflag: 0}) );

                        publicData.message = btcjs.Buffer.from( sighash, "hex" );
                        console.log( "here is the sighash:", sighash );
                        var div = document.createElement( "div" );
                        div.innerHTML = `<p>Phase 2 of 5 complete. Waiting for the coordinator to send everyone's session ids.</p>`;
                        $( '.participant' ).append( div );
                        var event2 = {
                            "content"   : encrypt( privKey, $_GET[ "pubkey" ], `{"phase":2, "session_shard": "${sessionShard}"}` ),
                            "created_at" : Math.floor( Date.now() / 1000 ),
                            "kind"      : 4,
                            "tags"      : [ [ 'p', $_GET[ "pubkey" ] ] ],
                            "pubkey"    : pubKey,
                        }
                        var signedEvent2 = await getSignedEvent(event2, privKey);
                        Object.keys( relays_obj ).forEach( function( relay ) {
                            relays_obj[ relay ].send(JSON.stringify([ "EVENT", signedEvent2 ]));
                        });
                    }
                }
            }
            var handlePreimages = async preimages => {
                if ( otherShardPreimages.length >= publicData.numberOfParticipants ) return;
                preimages.forEach( async preimage => {
                    var hashes = [];
                    Object.keys( otherShards ).forEach( item => hashes.push( otherShards[ item ] ));
                    if ( hashes.includes( bytesToHex( bitcoinjs.crypto.sha256( btcjs.Buffer.from( preimage, "hex" ) ) ) ) ) {
                        otherShardPreimages.push( preimage );
                    }
                    if ( otherShardPreimages.length == publicData.numberOfParticipants ) {
                        console.log( "time to tweak!" );
                        otherShardPreimages.forEach( function( item ) {
                            if ( !allShards ) {
                                allShards = otherShardPreimages[ 0 ];
                            } else {
                                allShards = add2Pubkeys( allShards, item );
                            }
                        });
                        console.log( "allshards:", allShards );
                        const sessionId = btcjs.randomBuffer(32); // must never be reused between sessions!
                        var idx = null;
                        publicData.pubKeys.every( function( key, index ) {
                            if ( bytesToHex( key ) == "81aaadc8a5e83f4576df823cf22a5b1969cf704a0d5f6f68bd757410c9917aac" ) {
                                idx = index;
                                return;
                            }
                            return true;
                        });
                        var my_idx = null;
                        publicData.pubKeys.every( function( key, index ) {
                            if ( bytesToHex( key ) == pubKey ) {
                                my_idx = index;
                                return;
                            }
                            return true;
                        });
                        console.log( "here is the idx:", idx );
                        //I used to think the "lowest" pubkey needed to share his or
                        //her signerPrivateData.session with all of the other signers
                        //because it is used in steps 7 and 10 as inputs to different
                        //functions. Since there is a warning that says stuff in the
                        //signerPrivateData object is never shared with the other
                        //signers, I decided to make the "known" signer have a
                        //shared "known" privkey of abab...abab, and construct a
                        //session for them by adding together points collected from
                        //everyone
                        knownSigner.session = btcjs.muSig.sessionInitialize(
                            btcjs.Buffer.from( allShards.substring( 2 ), "hex" ),
                            knownSigner.privateKey,
                            publicData.message,
                            publicData.pubKeyCombined,
                            publicData.pubKeyParity,
                            publicData.pubKeyHash,
                            idx
                        );
                        signerPrivateData.session = btcjs.muSig.sessionInitialize(
                            sessionId,
                            signerPrivateData.privateKey,
                            publicData.message,
                            publicData.pubKeyCombined,
                            publicData.pubKeyParity,
                            publicData.pubKeyHash,
                            my_idx
                        );
                        // signerSession = signerPrivateData.session;
                        //now we share our commitments
                        console.log( "individual commitment:", bytesToHex( signerPrivateData.session.commitment ) + ` <-- that is what I will share with everyone else, it should be different for everyone` );
                        console.log( "shared commitment:", bytesToHex( knownSigner.session.commitment ) + ` <-- that one is the same for everyone` );
                        var encrypted = encrypt( privKey, $_GET[ "pubkey" ], `{"phase":3,"info":"${bytesToHex( signerPrivateData.session.commitment )}"}` );
                        var event2 = {
                            "content"   : encrypted,
                            "created_at" : Math.floor( Date.now() / 1000 ),
                            "kind"      : 4,
                            "tags"      : [ [ 'p', $_GET[ "pubkey" ] ] ],
                            "pubkey"    : pubKey,
                        }
                        var signedEvent2 = await getSignedEvent(event2, privKey);
                        Object.keys( relays_obj ).forEach( function( relay ) {
                            relays_obj[ relay ].send(JSON.stringify([ "EVENT", signedEvent2 ]));
                        });
                    }
                });
            }
            var handleCommitments = async commitments => {
                console.log( commitments );
                var knowncommitments = [];
                publicData.commitments.forEach( item => knowncommitments.push( bytesToHex( item ) ) );
                commitments.forEach( item => {
                    if ( knowncommitments.includes( item ) ) return;
                    publicData.commitments.push( btcjs.Buffer.from( item, "hex" ) );
                });
                if ( !knowncommitments.includes( bytesToHex( knownSigner.session.commitment ) ) ) publicData.commitments.push( knownSigner.session.commitment );
                if ( publicData.commitments.length != publicData.numberOfParticipants + 1 ) return;
                if ( $( '.participant' ).innerText.toLowerCase().includes( "phase 3 of 5 complete" ) ) return;
                var div = document.createElement( "div" );
                div.innerHTML = `<p>Phase 3 of 5 complete. Waiting for the coordinator to send everyone's nonces.</p>`;
                $( '.participant' ).append( div );
                var encrypted = encrypt( privKey, $_GET[ "pubkey" ], `{"phase":4,"info":"${bytesToHex( signerPrivateData.session.nonce )}"}` );
                var event2 = {
                    "content"   : encrypted,
                    "created_at" : Math.floor( Date.now() / 1000 ),
                    "kind"      : 4,
                    "tags"      : [ [ 'p', $_GET[ "pubkey" ] ] ],
                    "pubkey"    : pubKey,
                }
                var signedEvent2 = await getSignedEvent(event2, privKey);
                Object.keys( relays_obj ).forEach( function( relay ) {
                    relays_obj[ relay ].send(JSON.stringify([ "EVENT", signedEvent2 ]));
                });
            }
            var handleNonces = async nonces => {
                var knownnonces = [];
                publicData.nonces.forEach( item => knownnonces.push( bytesToHex( item ) ) );
                nonces.forEach( item => {
                    if ( knownnonces.includes( item ) ) return;
                    publicData.nonces.push( btcjs.Buffer.from( item, "hex" ) );
                });
                if ( !knownnonces.includes( bytesToHex( knownSigner.session.nonce ) ) ) publicData.nonces.push( knownSigner.session.nonce );
                if ( publicData.nonces.length != publicData.numberOfParticipants + 1 ) return;
                if ( $( '.participant' ).innerText.toLowerCase().includes( "phase 4 of 5 complete" ) ) return;
                var div = document.createElement( "div" );
                div.innerHTML = `<p>Phase 4 of 5 complete. Waiting for the coordinator to aggregate the signatures and broadcast the transaction.</p>`;
                $( '.participant' ).append( div );
                publicData.nonceCombined = btcjs.muSig.sessionNonceCombine(signerPrivateData.session, publicData.nonces);
                signerPrivateData.session.combinedNonceParity = signerPrivateData.session.combinedNonceParity;
                knownSigner.session.combinedNonceParity = signerPrivateData.session.combinedNonceParity;
                signerPrivateData.session.partialSignature = btcjs.muSig.partialSign(signerPrivateData.session, publicData.message, publicData.nonceCombined, publicData.pubKeyCombined);
                knownSigner.session.partialSignature = btcjs.muSig.partialSign(knownSigner.session, publicData.message, publicData.nonceCombined, publicData.pubKeyCombined);
                console.log( "sig I am sending:", signerPrivateData.session.partialSignature );
                var encrypted = encrypt( privKey, $_GET[ "pubkey" ], `{"phase":5,"info":${JSON.stringify( signerPrivateData.session.partialSignature )}}` );
                var event2 = {
                    "content"   : encrypted,
                    "created_at" : Math.floor( Date.now() / 1000 ),
                    "kind"      : 4,
                    "tags"      : [ [ 'p', $_GET[ "pubkey" ] ] ],
                    "pubkey"    : pubKey,
                }
                var signedEvent2 = await getSignedEvent(event2, privKey);
                Object.keys( relays_obj ).forEach( function( relay ) {
                    relays_obj[ relay ].send(JSON.stringify([ "EVENT", signedEvent2 ]));
                });
            }
        </script>
        <script>
            async function handleMessage( message ) {
                var [ type, subId, event ] = JSON.parse( message.data );
                var { kind, content } = event || {}
                if (!event || event === true) return;
                // console.log('message:', event);
                if (kind === 4) content = await decrypt(privKey, event.pubkey, content);
                console.log( "content:", content );
                if (kind === 4 && event.pubkey == $_GET[ "pubkey" ]) {
                    content = JSON.parse( content );
                    if ( content[ "phase" ] == "request keys" ) {
                        var keys_and_shards = content[ "info" ];
                        Object.keys( keys_and_shards ).forEach( (item, index) => {
                            handleKey( Object.keys( keys_and_shards )[ index ], keys_and_shards[ Object.keys( keys_and_shards )[ index ] ] );
                        });
                    }
                    if ( content[ "phase" ] == 1 ) {
                        var keys_and_shards = content[ "info" ];
                        Object.keys( keys_and_shards ).forEach( (item, index) => {
                            handleKey( Object.keys( keys_and_shards )[ index ], keys_and_shards[ Object.keys( keys_and_shards )[ index ] ] );
                        });
                    }
                    if ( content[ "phase" ] == 2 ) {
                        handlePreimages( content[ "info" ] );
                    }
                    if ( content[ "phase" ] == 3 ) {
                        handleCommitments( content[ "info" ] );
                    }
                    if ( content[ "phase" ] == 4 ) {
                        handleNonces( content[ "info" ] );
                    }
                } else if ( kind === 4 && publicData.pubKeys.length < publicData.numberOfParticipants ) {
                    content = JSON.parse( content );
                    if ( content[ "phase" ] == 1 ) {
                        console.log( event.pubkey, content[ "session_hash" ] );
                        if ( !( event.pubkey in otherShards ) ) otherShards[ event.pubkey ] = content[ "session_hash" ];
                        var pubkeys = [];
                        publicData.pubKeys.forEach( item => {
                            pubkeys.push( bytesToHex( item ) );
                        });
                        if ( pubkeys.includes( event.pubkey ) ) return;
                        publicData.pubKeys.push( btcjs.Buffer.from( event.pubkey, 'hex' ) );
                        if ( publicData.pubKeys.length == publicData.numberOfParticipants ) {
                            var i; for ( i=0; i<Object.keys( otherShards ).length; i++ ) {
                                var encrypted = encrypt( privKey, Object.keys( otherShards )[ i ], `{"phase": 1,"info":${JSON.stringify( otherShards )}}` );
                                var event2 = {
                                    "content"   : encrypted,
                                    "created_at" : Math.floor( Date.now() / 1000 ),
                                    "kind"      : 4,
                                    "tags"      : [ [ 'p', Object.keys( otherShards )[ i ] ] ],
                                    "pubkey"    : pubKey,
                                }
                                var signedEvent2 = await getSignedEvent(event2, privKey);
                                Object.keys( relays_obj ).forEach( function( relay ) {
                                    relays_obj[ relay ].send(JSON.stringify([ "EVENT", signedEvent2 ]));
                                });
                            }
                            publicData.pubKeys.push( btcjs.Buffer.from( "81aaadc8a5e83f4576df823cf22a5b1969cf704a0d5f6f68bd757410c9917aac", 'hex' ) );
                            publicData.pubKeys.sort((a,b) => {var array = [bytesToHex(a),bytesToHex(b)].sort();if ( bytesToHex(a) == array[ 1 ]) return 1; else return -1;});
                            publicData.pubKeyHash = btcjs.muSig.computeEll(publicData.pubKeys);
                            const pkCombined = btcjs.muSig.pubKeyCombine(publicData.pubKeys, publicData.pubKeyHash);
                            publicData.pubKeyCombined = btcjs.convert.intToBuffer(pkCombined.affineX);
                            publicData.pubKeyParity = btcjs.math.isEven(pkCombined);
                            var combokey = publicData.pubKeyCombined.toString( "hex" );
                            var address = tapscript.Address.p2tr.encode( publicData.pubKeyCombined.toString( "hex" ), mempoolnet );
                            await getNote( "ready" );
                            $( '.coordinator' ).innerHTML = `<p>Phase 1 of 5 complete, everyone is ready. Please send bitcoin to this bitcoin address: ${address} -- this page should automatically detect when it arrives and move onto the next step</p>`;
                            console.log( "address:", address );
                            await waitSomeSeconds( 5 );
                            // var txid = prompt( "Enter the txid of your deposit" );
                            // var vout = prompt( "And the vout" );
                            // vout = Number( vout );
                            // var amt = prompt( "And the amount (in sats)" );
                            // amt = Number( amt );
                            await loopTilAddressReceivesMoney( address, mempoolNetwork );
                            await waitSomeSeconds( 2 );
                            var txinfo = await addressReceivedMoneyInThisTx( address, mempoolNetwork );
                            var txid = txinfo[ 0 ];
                            var vout = txinfo[ 1 ];
                            var amt = txinfo[ 2 ];
                            txdata = tapscript.Tx.create({
                              vin  : [{
                                txid: txid,
                                vout: vout,
                                prevout: {
                                  value: amt,
                                  scriptPubKey: [ 'OP_1', publicData.pubKeyCombined.toString( "hex" ) ]
                                },
                              }],
                              vout : [{
                                value: amt - 500,
                                //address: bcrt1q6zpf4gefu4ckuud3pjch563nm7x27u4ruahz3y
                                scriptPubKey: tapscript.Address.toScriptPubKey( publicData.address )
                              }]
                            });
                            the_tx.push( txdata );

                            var sighash = bytesToHex( tapscript.Signer.taproot.hash(txdata, 0, {sigflag: 0}) );

                            publicData.message = btcjs.Buffer.from( sighash, "hex" );
                            console.log( "here is the sighash:", sighash );
                            var div = document.createElement( "div" );
                            div.innerHTML = `<p>Phase 2 of 5 complete. Waiting for session ids to come in.</p><p>Known session ids: <span class="sessioncount">0</span>/${publicData.numberOfParticipants}</p>`;
                            $( '.coordinator' ).append( div );
                        }
                    }
                } else if ( kind === 4 && publicData.pubKeys.length >= publicData.numberOfParticipants ) {
                    content = JSON.parse( content );
                    if ( content[ "phase" ] == "request keys" ) {
                        console.log( "giving the keys" );
                        var reply = JSON.stringify( otherShards );
                        var encrypted = encrypt( privKey, event.pubkey, `{"phase": "request keys","info":${reply}}` );
                        var event2 = {
                            "content"   : encrypted,
                            "created_at" : Math.floor( Date.now() / 1000 ),
                            "kind"      : 4,
                            "tags"      : [ [ 'p', event.pubkey ] ],
                            "pubkey"    : pubKey,
                        }
                        var signedEvent2 = await getSignedEvent(event2, privKey);
                        Object.keys( relays_obj ).forEach( function( relay ) {
                            relays_obj[ relay ].send(JSON.stringify([ "EVENT", signedEvent2 ]));
                        });
                    }
                    if ( content[ "phase" ] == "request preimages" ) {
                        if ( otherShardPreimages.length != publicData.numberOfParticipants ) {
                            console.log( "not giving the preimages, too few:", otherShardPreimages.length, "| number needed:", publicData.numberOfParticipants );
                            return;
                        }
                        console.log( "giving the preimages" );
                        var encrypted = encrypt( privKey, event.pubkey, `{"phase":2,"info":${JSON.stringify( otherShardPreimages )}}` );
                        var event2 = {
                            "content"   : encrypted,
                            "created_at" : Math.floor( Date.now() / 1000 ),
                            "kind"      : 4,
                            "tags"      : [ [ 'p', event.pubkey ] ],
                            "pubkey"    : pubKey,
                        }
                        var signedEvent2 = await getSignedEvent(event2, privKey);
                        Object.keys( relays_obj ).forEach( function( relay ) {
                            relays_obj[ relay ].send(JSON.stringify([ "EVENT", signedEvent2 ]));
                        });
                    }
                    if ( content[ "phase" ] == "request commitments" ) {
                        console.log( "giving the commitments" );
                        var info_to_share = [];
                        publicData.commitments.forEach( item => info_to_share.push( bytesToHex( item ) ));
                        var encrypted = encrypt( privKey, event.pubkey, `{"phase":3,"info":${JSON.stringify( info_to_share )}}` );
                        var event2 = {
                            "content"   : encrypted,
                            "created_at" : Math.floor( Date.now() / 1000 ),
                            "kind"      : 4,
                            "tags"      : [ [ 'p', event.pubkey ] ],
                            "pubkey"    : pubKey,
                        }
                        var signedEvent2 = await getSignedEvent(event2, privKey);
                        Object.keys( relays_obj ).forEach( function( relay ) {
                            // relays_obj[ relay ].send(JSON.stringify([ "EVENT", signedEvent2 ]));
                        });
                    }
                    if ( content[ "phase" ] == "request nonces" ) {
                        console.log( "giving the nonces" );
                        var info_to_share = [];
                        var alt_nonceorder = [...nonceorder];
                        alt_nonceorder.forEach( (item, index) => {
                            if ( item[ 0 ] == "81aaadc8a5e83f4576df823cf22a5b1969cf704a0d5f6f68bd757410c9917aac" ) alt_nonceorder.splice( index, 1 )
                        });
                        alt_nonceorder.forEach( item => info_to_share.push( bytesToHex( item[ 1 ] ) ) );
                        var encrypted = encrypt( privKey, event.pubkey, `{"phase":4,"info":${JSON.stringify( info_to_share )}}` );
                        var event2 = {
                            "content"   : encrypted,
                            "created_at" : Math.floor( Date.now() / 1000 ),
                            "kind"      : 4,
                            "tags"      : [ [ 'p', event.pubkey ] ],
                            "pubkey"    : pubKey,
                        }
                        var signedEvent2 = await getSignedEvent(event2, privKey);
                        Object.keys( relays_obj ).forEach( function( relay ) {
                            relays_obj[ relay ].send(JSON.stringify([ "EVENT", signedEvent2 ]));
                        });
                    }
                    if ( content[ "phase" ] == 0 ) {
                        if ( ready.includes( event.pubkey ) ) return;
                        ready.push( event.pubkey );
                        if ( ready.length == publicData.numberOfParticipants ) {
                            sessionStorage.ready = "true";
                        } else {
                            console.log( "not ready yet! number of ready people:", ready.length, " | number needed:", publicData.numberOfParticipants );
                        }
                    }
                    if ( content[ "phase" ] == 2 ) {
                        if ( shardgivers.includes( event.pubkey ) ) return;
                        shardgivers.push( event.pubkey );
                        if ( bytesToHex( bitcoinjs.crypto.sha256( btcjs.Buffer.from( content[ "session_shard" ], "hex" ) ) ) == otherShards[ event.pubkey ] ) {
                            otherShardPreimages.push( content[ "session_shard" ] );
                            if ( otherShardPreimages.length == publicData.numberOfParticipants ) {
                                console.log( "time to tweak!" );
                                otherShardPreimages.forEach( function( item ) {
                                    if ( !allShards ) {
                                        allShards = otherShardPreimages[ 0 ];
                                    } else {
                                        allShards = add2Pubkeys( allShards, item );
                                    }
                                });
                                console.log( "allshards:", allShards );
                                var idx = null;
                                publicData.pubKeys.every( function( key, index ) {
                                    if ( bytesToHex( key ) == "81aaadc8a5e83f4576df823cf22a5b1969cf704a0d5f6f68bd757410c9917aac" ) {
                                        idx = index;
                                        return;
                                    }
                                    return true;
                                });
                                await waitSomeSeconds( 2 );
                                console.log( "session id:", btcjs.Buffer.from( allShards.substring( 2 ), "hex" ) );
                                console.log( "privkey:", knownSigner.privateKey );
                                console.log( "message:", publicData.message );
                                console.log( "combo pubkey:", publicData.pubKeyCombined );
                                console.log( "combo parity:", publicData.pubKeyParity );
                                console.log( "combo hash:", publicData.pubKeyHash );
                                console.log( "idx:", idx );
                                knownSigner.session = btcjs.muSig.sessionInitialize(
                                    btcjs.Buffer.from( allShards.substring( 2 ), "hex" ),
                                    knownSigner.privateKey,
                                    publicData.message,
                                    publicData.pubKeyCombined,
                                    publicData.pubKeyParity,
                                    publicData.pubKeyHash,
                                    idx
                                );
                                var i; for ( i=0; i<publicData.pubKeys.length; i++ ) {
                                    var item = bytesToHex( publicData.pubKeys[ i ] );
                                    var encrypted = encrypt( privKey, item, `{"phase":2,"info":${JSON.stringify( otherShardPreimages )}}` );
                                    var event2 = {
                                        "content"   : encrypted,
                                        "created_at" : Math.floor( Date.now() / 1000 ),
                                        "kind"      : 4,
                                        "tags"      : [ [ 'p', item ] ],
                                        "pubkey"    : pubKey,
                                    }
                                    var signedEvent2 = await getSignedEvent(event2, privKey);
                                    Object.keys( relays_obj ).forEach( function( relay ) {
                                        relays_obj[ relay ].send(JSON.stringify([ "EVENT", signedEvent2 ]));
                                    });
                                    await waitSomeSeconds( 1 );
                                }
                            }
                        }
                    }
                    if ( content[ "phase" ] == 3 ) {
                        if ( commitments.includes( event.pubkey ) ) return;
                        commitments.push( event.pubkey );
                        console.log( "woot, I am in phase 3!" );
                        if ( Number( $( '.sessioncount' ).innerText ) < publicData.numberOfParticipants ) {
                            $( '.sessioncount' ).innerText = Number( $( '.sessioncount' ).innerText ) + 1;
                        }
                        console.log( "committing something!", publicData.commitments.length );
                        publicData.commitments.push( btcjs.Buffer.from( content[ "info" ], "hex" ) );
                        if ( publicData.commitments.length == publicData.numberOfParticipants ) {
                            var div = document.createElement( "div" );
                            div.innerHTML = `<p>Phase 3 of 5 complete. Waiting for nonces to come in.</p><p>Known nonces: <span class="noncecount">0</span>/${publicData.numberOfParticipants}</p>`;
                            $( '.coordinator' ).append( div );
                            var info_to_share = [];
                            publicData.commitments.forEach( item => info_to_share.push( bytesToHex( item ) ));
                            console.log( "sharing these commitments:", info_to_share );
                            var i; for ( i=0; i<publicData.pubKeys.length; i++ ) {
                                var item = bytesToHex( publicData.pubKeys[ i ] );
                                var encrypted = encrypt( privKey, item, `{"phase":3,"info":${JSON.stringify( info_to_share )}}` );
                                var event2 = {
                                    "content"   : encrypted,
                                    "created_at" : Math.floor( Date.now() / 1000 ),
                                    "kind"      : 4,
                                    "tags"      : [ [ 'p', item ] ],
                                    "pubkey"    : pubKey,
                                }
                                var signedEvent2 = await getSignedEvent(event2, privKey);
                                Object.keys( relays_obj ).forEach( function( relay ) {
                                    relays_obj[ relay ].send(JSON.stringify([ "EVENT", signedEvent2 ]));
                                });
                                await waitSomeSeconds( 1 );
                            }
                            console.log( "committing something!", publicData.commitments.length );
                            publicData.commitments.push( knownSigner.session.commitment );
                        }
                    }
                    if ( content[ "phase" ] == 4 ) {
                        var received = [];
                        nonceorder.forEach( item => {
                            received.push( item[ 0 ] );
                        });
                        if ( received.includes( event.pubkey ) ) return;
                        console.log( "woot, I am in phase 4!" );
                        if ( Number( $( '.noncecount' ).innerText ) < publicData.numberOfParticipants ) {
                            $( '.noncecount' ).innerText = Number( $( '.noncecount' ).innerText ) + 1;
                        }
                        nonceorder.push( [event.pubkey, btcjs.Buffer.from( content[ "info" ], "hex" )] );
                        // publicData.nonces.push( btcjs.Buffer.from( content[ "info" ], "hex" ) );
                        if ( nonceorder.length == publicData.numberOfParticipants ) {
                            var div = document.createElement( "div" );
                            div.innerHTML = `<p>Phase 4 of 5 complete. Waiting for signatures to come in.</p><p>Known signatures: <span class="sigcount">0</span>/${publicData.numberOfParticipants}</p>`;
                            $( '.coordinator' ).append( div );
                            var info_to_share = [];
                            nonceorder.forEach( item => info_to_share.push( bytesToHex( item[ 1 ] ) ));
                            console.log( "sharing these nonces:", info_to_share );
                            nonceorder.push( ["81aaadc8a5e83f4576df823cf22a5b1969cf704a0d5f6f68bd757410c9917aac",knownSigner.session.nonce] );
                            nonceorder.sort((a,b) => {var array = [a[ 0 ],b[ 0 ]].sort();if ( a[ 0 ] == array[ 1 ]) return 1; else return -1;});
                            nonceorder.forEach( item => publicData.nonces.push( item[ 1 ] ) );
                            await waitForNonces();
                            var i; for ( i=0; i<publicData.pubKeys.length; i++ ) {
                                var item = bytesToHex( publicData.pubKeys[ i ] );
                                if ( item != "81aaadc8a5e83f4576df823cf22a5b1969cf704a0d5f6f68bd757410c9917aac" ) {
                                    var encrypted = encrypt( privKey, item, `{"phase":4,"info":${JSON.stringify( info_to_share )}}` );
                                    var event2 = {
                                        "content"   : encrypted,
                                        "created_at" : Math.floor( Date.now() / 1000 ),
                                        "kind"      : 4,
                                        "tags"      : [ [ 'p', item ] ],
                                        "pubkey"    : pubKey,
                                    }
                                    var signedEvent2 = await getSignedEvent(event2, privKey);
                                    Object.keys( relays_obj ).forEach( function( relay ) {
                                        relays_obj[ relay ].send(JSON.stringify([ "EVENT", signedEvent2 ]));
                                    });
                                    await waitSomeSeconds( 1 );
                                }
                            }
                        }
                    }
                    if ( content[ "phase" ] == 5 ) {
                        var received = [];
                        sigorder.forEach( item => {
                            received.push( item[ 0 ] );
                        });
                        if ( received.includes( event.pubkey ) ) return;
                        if ( Number( $( '.sigcount' ).innerText ) < publicData.numberOfParticipants ) {
                            $( '.sigcount' ).innerText = Number( $( '.sigcount' ).innerText ) + 1;
                        }
                        console.log( "woot, I am in phase 5!" );
                        if ( !sigorder.length ) {
                            console.log( "nonces:", publicData.nonces );
                            publicData.nonceCombined = btcjs.muSig.sessionNonceCombine(knownSigner.session, publicData.nonces);
                            knownSigner.session.partialSignature = btcjs.muSig.partialSign(knownSigner.session, publicData.message, publicData.nonceCombined, publicData.pubKeyCombined);
                            sigorder.push( ["81aaadc8a5e83f4576df823cf22a5b1969cf704a0d5f6f68bd757410c9917aac",knownSigner.session.partialSignature] );
                            var i; for ( i=0; i<publicData.numberOfParticipants + 1; i++ ) {
                                altsessions.push({
                                    "privateKey": bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ),
                                    session: null
                                });
                            }
                            altsessions.forEach( item => {
                                item.session = btcjs.muSig.sessionInitialize(
                                    btcjs.Buffer.from( "abababababababababababababababababababababababababababababababab", "hex" ),
                                    btcjs.BigInteger.fromHex( "abababababababababababababababababababababababababababababababab" ),
                                    publicData.message,
                                    publicData.pubKeyCombined,
                                    publicData.pubKeyParity,
                                    publicData.pubKeyHash,
                                    0
                                );
                                item.session.partialSignature = btcjs.muSig.partialSign(item.session, publicData.message, publicData.nonceCombined, publicData.pubKeyCombined);
                            });
                        }
                        var i; for ( i=0; i<publicData.pubKeys.length; i++ ) {
                            console.log( 0 );
                            if ( bytesToHex( publicData.pubKeys[ i ] ) != event.pubkey ) continue;
                            console.log( 1 );
                            var psig = altsessions[ i ].session.partialSignature;
                            var sigdata = content[ "info" ];
                            psig[ 0 ] = sigdata[ 0 ];
                            psig[ 1 ] = sigdata[ 1 ];
                            psig[ 2 ] = sigdata[ 2 ];
                            psig[ 3 ] = sigdata[ 3 ];
                            psig[ 4 ] = sigdata[ 4 ];
                            psig[ 5 ] = sigdata[ 5 ];
                            psig[ 6 ] = sigdata[ 6 ];
                            psig[ 7 ] = sigdata[ 7 ];
                            psig[ 8 ] = sigdata[ 8 ];
                            psig[ 9 ] = sigdata[ 9 ];
                            psig[ 10 ] = sigdata[ 10 ];
                            psig[ 11 ] = sigdata[ 11 ];
                            psig[ 12 ] = sigdata[ 12 ];
                            psig[ 13 ] = sigdata[ 13 ];
                            psig[ 14 ] = sigdata[ 14 ];
                            psig[ 15 ] = sigdata[ 15 ];
                            psig[ 16 ] = sigdata[ 16 ];
                            psig[ 17 ] = sigdata[ 17 ];
                            psig[ 18 ] = sigdata[ 18 ];
                            psig[ 19 ] = sigdata[ 19 ];
                            psig[ 20 ] = sigdata[ 20 ];
                            psig[ "s" ] = sigdata[ "s" ];
                            psig[ "t" ] = sigdata[ "t" ];
                            sigorder.push( [event.pubkey, psig ] );
                        }
                        if ( sigorder.length == publicData.numberOfParticipants + 1 ) {
                            sigorder.sort((a,b) => {var array = [a[ 0 ],b[ 0 ]].sort();if ( a[ 0 ] == array[ 1 ]) return 1; else return -1;});
                            sigorder.forEach( item => privateSigners.push( {session: {partialSignature: item[ 1 ]}} ));
                            for (let i = 0; i < publicData.pubKeys.length; i++) {
                                publicData.partialSignatures[i] = privateSigners[i].session.partialSignature;
                            }
                            for (let i = 0; i < publicData.pubKeys.length; i++) {
                                btcjs.muSig.partialSigVerify(
                                    knownSigner.session,
                                    publicData.partialSignatures[i],
                                    publicData.nonceCombined,
                                    i,
                                    publicData.pubKeys[i],
                                    publicData.nonces[i]
                                );
                            }
                            publicData.signature = btcjs.muSig.partialSigCombine(publicData.nonceCombined, publicData.partialSignatures);
                            console.log( "sig is good, right?", btcjs.sigverifier(publicData.pubKeyCombined, publicData.message, publicData.signature) );
                            the_tx[ 0 ].vin[0].witness = [ publicData.signature ];
                            console.log( 'txhex:', tapscript.Tx.encode(the_tx[ 0 ]).hex );
                            var div = document.createElement( "div" );
                            div.innerHTML = `<p>txhex: ${tapscript.Tx.encode(the_tx[ 0 ]).hex}</p><p>Broadcast it here: https://mempool.space/${mempoolNetwork}tx/push</p>`;
                            $( '.coordinator' ).append( div );
                        }
                    }
                }
            }

            async function openConnection( e ) {
                console.log( "connected to " + this.url );
                var subId   = bitcoinjs.ECPair.makeRandom().privateKey.toString( "hex" ).substring( 0, 16 );
                var filter  = { "#p": [ pubKey ] }
                var subscription = [ "REQ", subId, filter ];
                Object.keys( relays_obj ).forEach( function( relay ) {
                    relays_obj[ relay ].send(JSON.stringify( subscription ));
                });
                if ( $_GET[ "pubkey" ] ) {
                    var event2 = {
                        "content"   : encrypt( privKey, $_GET[ "pubkey" ], `{"phase":1, "session_hash": "${sessionHash}"}` ),
                        "created_at" : Math.floor( Date.now() / 1000 ),
                        "kind"      : 4,
                        "tags"      : [ [ 'p', $_GET[ "pubkey" ] ] ],
                        "pubkey"    : pubKey,
                    }
                    var signedEvent2 = await getSignedEvent(event2, privKey);
                    this.send(JSON.stringify([ "EVENT", signedEvent2 ]));
                }
            }
            async function getSignedEvent(event, privateKey) {
                var eventData = JSON.stringify([
                    0,                  // Reserved for future use
                    event['pubkey'],        // The sender's public key
                    event['created_at'],    // Unix timestamp
                    event['kind'],      // Message “kind” or type
                    event['tags'],      // Tags identify replies/recipients
                    event['content']        // Your note contents
                ])
                event.id  = sha256( eventData ).toString( 'hex' );
                event.sig = await schnorr.sign( event.id, privateKey );
                return event;
            }
            function hexToBytes( hex ) {
                return Uint8Array.from( hex.match( /.{1,2}/g ).map( ( byte ) => parseInt( byte, 16 ) ) );
            }

            function bytesToHex( bytes ) {
                return bytes.reduce( ( str, byte ) => str + byte.toString( 16 ).padStart( 2, '0' ), '' );
            }
            function base64ToHex( str ) {
                var raw = atob( str );
                var result = '';
                var i; for ( i=0; i<raw.length; i++ ) {
                    var hex = raw.charCodeAt( i ).toString( 16 );
                    result += ( hex.length === 2 ? hex : '0' + hex );
                }
                return result;
            }
            function encrypt( privkey, pubkey, text ) {
                var key = nobleSecp256k1.getSharedSecret( privkey, '02' + pubkey, true ).substring( 2 );
                var iv = window.crypto.getRandomValues(new Uint8Array(16));
                var cipher = browserifyCipher.createCipheriv( 'aes-256-cbc', hexToBytes( key ), iv );
                var encryptedMessage = cipher.update(text,"utf8","base64");
                emsg = encryptedMessage + cipher.final( "base64" );
                var uint8View = new Uint8Array( iv.buffer );
                var decoder = new TextDecoder();
                return emsg + "?iv=" + btoa( String.fromCharCode.apply( null, uint8View ) );
            }
            function decrypt( privkey, pubkey, ciphertext ) {
                var [ emsg, iv ] = ciphertext.split( "?iv=" );
                var key = nobleSecp256k1.getSharedSecret( privkey, '02' + pubkey, true ).substring( 2 );
                var decipher = browserifyCipher.createDecipheriv(
                    'aes-256-cbc',
                    hexToBytes( key ),
                    hexToBytes( base64ToHex( iv ) )
                );
                var decryptedMessage = decipher.update( emsg, "base64" );
                dmsg = decryptedMessage + decipher.final( "utf8" );
                return dmsg;
            }
            async function loopTilAddressReceivesMoney(address, network) {
                let itReceivedMoney = false;
                async function isDataSetYet(data_i_seek) {
                    return new Promise(function (resolve, reject) {
                        if (!data_i_seek) {
                            setTimeout(async function () {
                                console.log("waiting for address to receive money...");
                                try {
                                    itReceivedMoney = await addressOnceHadMoney(address, network);
                                }catch(e){ }
                                let msg = await isDataSetYet(itReceivedMoney);
                                resolve(msg);
                            }, 2000);
                        } else {
                            resolve(data_i_seek);
                        }
                    });
                }

                async function getTimeoutData() {
                    let data_i_seek = await isDataSetYet(itReceivedMoney);
                    return data_i_seek;
                }

                let returnable = await getTimeoutData();
                return returnable;
            }

            async function addressReceivedMoneyInThisTx(address, network) {
                let txid;
                let vout;
                let amt;
                let nonjson = await getData("https://mempool.space/" + network + "api/address/" + address + "/txs");
                let json = JSON.parse(nonjson);
                json.forEach(function (tx) {
                    tx["vout"].forEach(function (output, index) {
                        if (output["scriptpubkey_address"] == address) {
                            txid = tx["txid"];
                            vout = index;
                            amt = output["value"];
                        }
                    });
                });
                return [txid, vout, amt];
            }
            async function addressOnceHadMoney( address, network ) {
                var nonjson = await getData( "https://mempool.space/" + network + "api/address/" + address );
                var json = JSON.parse( nonjson );
                if ( json[ "chain_stats" ][ "tx_count" ] > 0 || json[ "mempool_stats" ][ "tx_count" ] > 0 ) {
                    return true;
                }
                return false;
            }
            function getData( url ) {
                return new Promise( async function( resolve, reject ) {
                    function inner_get( url ) {
                        var xhttp = new XMLHttpRequest();
                        xhttp.open( "GET", url, true );
                        xhttp.send();
                        return xhttp;
                    }
                    var data = inner_get( url );
                    data.onerror = function( e ) {
                        resolve( "error" );
                    }
                    async function isResponseReady() {
                        return new Promise( function( resolve2, reject ) {
                            if ( !data.responseText || data.readyState != 4 ) {
                                setTimeout( async function() {
                                    var msg = await isResponseReady();
                                    resolve2( msg );
                                }, 1 );
                            } else {
                                resolve2( data.responseText );
                            }
                        });
                    }
                    var returnable = await isResponseReady();
                    resolve( returnable );
                });
            }
            async function addressOnceSentMoney( address, network ) {
                var nonjson = await getData( "https://mempool.space/" + network + "api/address/" + address );
                var json = JSON.parse( nonjson );
                if ( json[ "chain_stats" ][ "spent_txo_count" ] > 0 || json[ "mempool_stats" ][ "spent_txo_count" ] > 0 ) {
                    return true;
                }
                return false;
            }
            async function addressSentMoneyInThisTx( address, network ) {
                var funding_txid = sessionStorage.funding_txid;
                return new Promise( async function( resolve, reject ) {
                    var nonjson = await getData( "https://mempool.space/" + network + "/api/address/" + address + "/txs" );
                    json = JSON.parse( nonjson );
                    json.forEach( function( tx ) {
                        tx[ "vin" ].forEach( function( input ) {
                            if ( input[ "txid" ] == funding_txid ) {
                                resolve( tx[ "txid" ] );
                            }
                        });
                    });
                });
            }
            async function loopTilAddressSendsMoney(address, network) {
                let itSentMoney = false;
                async function isDataSetYet(data_i_seek) {
                    return new Promise(function (resolve, reject) {
                        if (!data_i_seek) {
                            setTimeout(async function () {
                                console.log("waiting for address to send money...");
                                try {
                                    itSentMoney = await addressOnceSentMoney(address, network);
                                }catch(e){ }
                                let msg = await isDataSetYet(itSentMoney);
                                resolve(msg);
                            }, 2000);
                        } else {
                            resolve(data_i_seek);
                        }
                    });
                }

                async function getTimeoutData() {
                    let data_i_seek = await isDataSetYet(itSentMoney);
                    return data_i_seek;
                }

                let returnable = await getTimeoutData();
                return returnable;
            }
            var watchForMovement = async (address, network) => {
                await loopTilAddressSendsMoney(address, network);
                var txid = await addressSentMoneyInThisTx( address, network );
                var div = document.createElement( "div" );
                div.innerHTML = `<p>Phase 5 of 5 complete. Here is the transaction: https://mempool.space/${network}tx/${txid}</p>`;
                $( '.participant' ).append( div );
            }
            var getDataFromNostr = async (type) => {
                if ( type == "keys" ) {
                    var phase = "request keys"
                }
                if ( type == "preimages" ) {
                    var phase = "request preimages"
                }
                if ( type == "commitments" ) {
                    var phase = "request commitments"
                }
                if ( type == "nonces" ) {
                    var phase = "request nonces"
                }

                var event = {
                    "content"    : encrypt( privKey, $_GET[ "pubkey" ], `{"phase": "${phase}"}` ),
                    "created_at" : Math.floor( Date.now() / 1000 ),
                    "kind"       : 4,
                    "tags"       : [ [ 'p', $_GET[ "pubkey" ] ] ],
                    "pubkey"     : pubKey,
                }
                var signedEvent = await getSignedEvent(event, privKey);
                Object.keys( relays_obj ).forEach( function( relay ) {
                    relays_obj[ relay ].send(JSON.stringify([ "EVENT", signedEvent ]));
                });
            }
        </script>
    </head>
    <body>
        <h1>Musig playground</h1>
        <p>In this playground you will do a bitcoin transaction (on testnet) in which many people send some fake money to one bitcoin address but it will look like just one person sent it</p>
        <div class="coordinator">
            <p>Please enter how many people you want to do this with (a very large number makes failure more likely -- usually due to a dropped connection or a missed message, but a very large number can even make your browser crash. Even as few as 5 rarely works for me right now so be conservative)</p>
            <input type="number">
            <p>Please enter a testnet bitcoin address where the fake money should go after the demo</p>
            <input>
            <p><button>Submit</button></p>
            <div class="sharables"></div>
        </div>
        <div class="participant"></div>
        <script>
            $( 'button' ).onclick = () => {
                publicData.numberOfParticipants = Math.floor( Number( $( 'input' ).value ) );
                publicData.address = $$( 'input' )[ 1 ].value;
                var url = window.location.protocol + "//" + window.location.hostname + window.location.pathname +
                `?pubkey=${pubKey}&count=${publicData.numberOfParticipants}&address=${publicData.address}`;
                if ( $_GET[ "network" ] ) url += "&network=" + $_GET[ "network" ];
                $( '.sharables' ).innerHTML = `<p>Share this link with each person you're doing this with:</p><p><a href="${url}" target="_blank">${url}</a></p>`;
            }
        </script>
        <script>
            if ( $_GET[ "pubkey" ] ) {
                $( '.coordinator' ).style.display = "none";
                $( '.participant' ).style.display = "block";
                $( '.participant' ).innerHTML += `<p>You are currently waiting for the coordinator to share the pubkeys of the other ${$_GET[ "count" ] - 1} participants with you. Please be patient.</span></p>`;
                publicData.numberOfParticipants = Number( $_GET[ "count" ] );
                publicData.pubKeys.push( btcjs.Buffer.from( pubKey, 'hex' ) );
                publicData.address = $_GET[ "address" ];
            }
        </script>
        <script>
            var openConnections = async () => {
                var i; for ( i=0; i<relays.length; i++ ) {
                    var myrelay = relays[ i ];
                    relays_obj[ myrelay ] = new WebSocket( myrelay );
                    relays_obj[ myrelay ].addEventListener( 'open', openConnection );
                    relays_obj[ myrelay ].addEventListener( 'message', handleMessage );
                    await waitSomeSeconds( 1 );
                }
            }
            openConnections();
            function checkHeartbeat() {
                setTimeout( () => {
                    //it is important that this be inside the timeout otherwise
                    //it may detect a connection loss on pageload
                    Object.keys( relays_obj ).forEach( function( relay ) {
                        if ( relays_obj[ relay ].readyState != 1 ) {
                            relays_obj[ relay ] = new WebSocket( relay );
                            relays_obj[ relay ].removeEventListener( 'open', openConnection );
                            relays_obj[ relay ].removeEventListener( 'message', handleMessage );
                            relays_obj[ relay ] = new WebSocket( relay );
                            relays_obj[ relay ].addEventListener( 'message', handleMessage );
                            relays_obj[ relay ].addEventListener( 'open', openConnection );
                        }
                    });
                    checkHeartbeat();
                    if ( $_GET[ "pubkey" ] && ( publicData.pubKeys.length != publicData.numberOfParticipants + 1 ) ) {
                        if ( !$( '.participant' ).innerText.toLowerCase().includes( "phase 1 of 5 complete" ) ) {
                            // getDataFromNostr( "keys" );
                        }
                    }
                    if ( $( '.participant' ).innerText.toLowerCase().includes( "phase 2 of 5 complete" ) && !$( '.participant' ).innerText.toLowerCase().includes( "phase 3 of 5 complete" ) ) {
                        if ( otherShardPreimages.length != publicData.numberOfParticipants ) getDataFromNostr( "preimages" ); else getDataFromNostr( "commitments" );
                    }
                    if ( $( '.participant' ).innerText.toLowerCase().includes( "phase 3 of 5 complete" ) && !$( '.participant' ).innerText.toLowerCase().includes( "phase 4 of 5 complete" ) ) {
                        console.log( "getting nonces" );
                        getDataFromNostr( "nonces" );
                    }
                }, 10000 );
            }
            checkHeartbeat();
        </script>
    </body>
</html>
